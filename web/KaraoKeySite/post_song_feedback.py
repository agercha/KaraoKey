################################################################################
# post_song_feedback.py
#
# This file contains all the functions that implement the post song synchronous 
# feedback. For instantaneous feedback generation functionality, look to 
# feedback.py
# 
# Test functions can be found in feedback_tests.py
################################################################################
import json, math
from KaraoKeySite.feedback import *

# TODO: This global should be pulled in from feedback.py, instead of redeclared
# here. For now, assert at this value should be the same. 
NOTE_WEIGHTING = 70 
def get_hits_misses_data(scores):
    '''
    Given an input array of floats representing scores, returns the number of
    hits, near misses, and misses. 

    Parameters:
        scores: an array of floats representing scores. This information should
                be generated by the instantenous feedback mechanism.
    Return value:
        Tuple of (hits, near_misses, misses)
        hits: number of scores that are accurate enough to be considered hits
        near_misses: number of scores that are accurate enough to be considered\
                     near misses
        misses: number of scores that were not accurate.
    '''
    
    hits = 0
    near_misses = 0 
    misses = 0

    for score in scores:
        if score >= NOTE_WEIGHTING:
            hits += 1
        elif score >= NOTE_WEIGHTING * 0.7:
            near_misses += 1
        else:
            misses += 1

    return hits, near_misses, misses

def get_score_ratios(scores):
    '''
    Given an input array of floats representing scores, returns the ratio of
    hits, near misses, and misses. Data is used in a pie chart visual in the 
    post song feedback page. 

    Parameters:
        scores: an array of floats representing scores. This information should
                be generated by the instantenous feedback mechanism.
    Return value:
        ratio of (hits, near_misses, misses), normalized to 1
    '''

    hits, near_misses, misses = get_hits_misses_data(scores)
    total = hits + near_misses + misses

    return (hits/total, near_misses/total, misses/total)

def get_worst_chunk_feedback(curr_discrepancy:list):
    total = len(curr_discrepancy)
    sharp = curr_discrepancy.count(1) / total
    on_pitch = curr_discrepancy.count(0) / total
    flat = curr_discrepancy.count(-1) / total

    if abs(sharp - flat) < 0.1:
        return "You were shaky during this section. Neither sharp or flat, but off-tune."
    elif sharp > flat:
        return "In this section, you leaned sharp (above the target pitch)."
    else:
        return "In this section, you leaned flat (below the target pitch)."
    
def get_best_chunk_feedback(curr_discrepancy:list):
    total = len(curr_discrepancy)
    sharp = curr_discrepancy.count(1) / total
    on_pitch = ( curr_discrepancy.count(0) / total ) * 100
    flat = curr_discrepancy.count(-1) / total

    return f"In your best sung section, you sang on pitch {round(on_pitch,2)}% of the time."

def get_discrepancy_data(input_json_filepath:str, user_freqs:list):
    # this will probably need to be modified once we actually have the actual
    # file directory.
    with open(input_json_filepath) as f:
        test_data = json.load(f)

    worst_outer_chunk = -1
    largest_discrepancy = -1
    worst_qualitative_feedback = ""

    best_outer_chunk = -1
    smallest_discrepancy = math.inf
    best_qualitative_feedback = ""
    
    user_index = 0
    num_outer_chunks = len(test_data)
    # loop over all the partitions of the song
    for outer_index in range(num_outer_chunks):
        outer_chunk = test_data[outer_index]

        # obtain list of target and user frequencies
        target_freqs = outer_chunk["target"]

        # Accumulate inner chunk discrepancy
        curr_discrepancy = []

        # loop over all the inner frequencies contained in each outer chunk
        for inner_index in range(len(target_freqs)):
            target_freq = target_freqs[inner_index]
            if user_index < len(user_freqs): 
                user_freq = user_freqs[user_index]
            else:
                user_freq = 0
            score = get_accuracy_score(target_freq, user_freq)
            relative = get_sharp_or_flat(user_freq, target_freq, score)
            curr_discrepancy.append(relative)
            user_index += 1

        abs_discrepancy = sum(abs(num) for num in curr_discrepancy)
        if abs_discrepancy > largest_discrepancy:
            largest_discrepancy = abs_discrepancy
            worst_outer_chunk = outer_index
            worst_outer_chunk_ind2 = user_index
            worst_outer_chunk_ind1 = worst_outer_chunk_ind2 - len(target_freqs)
            worst_qualitative_feedback = get_worst_chunk_feedback(curr_discrepancy)
            worst_res = (worst_outer_chunk, worst_outer_chunk_ind1, worst_outer_chunk_ind2, worst_qualitative_feedback)

        elif abs_discrepancy < smallest_discrepancy:
            smallest_discrepancy = abs_discrepancy
            best_outer_chunk = outer_index
            best_outer_chunk_ind2 = user_index
            best_outer_chunk_ind1 = best_outer_chunk_ind2 - len(target_freqs)
            best_qualitative_feedback = get_best_chunk_feedback(curr_discrepancy)
            best_res = (best_outer_chunk, best_outer_chunk_ind1, best_outer_chunk_ind2, best_qualitative_feedback)

    return (worst_res, best_res)


def json_post_frequency_feedback(input_json_filepath:str, user_freqs:list):
    '''
    Given an input json file containing 1:1 mappings of user and target\
    frequencies, calculates an accuracy score. 

    Parameters:
        input_json_filepath: a 1:1 mapping of user to target freqeuencies.
        Expects a format of:
            [{
                "length": int
                "target": [array, of, floats]
                "user": [array, of, floats]
                "lyrics" : "string"
            }]
        
    Return value:
        A comprehensive score ranging from [0, 1] reflecting how accurately the 
        user was singing to the target frequency.
    '''

    # this will probably need to be modified once we actually have the actual
    # file directory.
    with open(input_json_filepath) as f:
        test_data = json.load(f)
    
    user_index = 0
    total_scores = []
    num_outer_chunks = len(test_data)
    # loop over all the partitions of the song
    for outer_index in range(num_outer_chunks):
        outer_chunk = test_data[outer_index]

        # obtain list of target and user frequencies
        target_freqs = outer_chunk["target"]

        # loop over all the inner frequencies contained in each outer chunk
        for inner_index in range(len(target_freqs)):
            target_freq = target_freqs[inner_index]
            if user_index < len(user_freqs): 
                user_freq = user_freqs[user_index]
            else:
                user_freq = 0
            score = get_accuracy_score(target_freq, user_freq)
            if (score != 0): total_scores.append(score) # hmmmm...
            user_index += 1

    print(sum(total_scores) / len(total_scores))
    return sum(total_scores) / len(total_scores)